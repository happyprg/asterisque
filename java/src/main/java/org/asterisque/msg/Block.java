/*
 * Copyright (c) 2014 koiroha.org.
 * All sources and related resources are available under Apache License 2.0.
 * http://www.apache.org/licenses/LICENSE-2.0.html
*/
package org.asterisque.msg;

import org.asterisque.Asterisque;

import java.nio.ByteBuffer;
import java.nio.charset.Charset;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Block
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/**
 * {@link org.asterisque.Pipe} を経由して双方向で交換可能なメッセージです。
 *
 * @author Takami Torao
 */
public final class Block extends Message {

	// ==============================================================================================
	// 最大ペイロードサイズ
	// ==============================================================================================
	/**
	 * ペイロードに設定できる最大サイズです。0xEFFF (61,439バイト) を表します。
	 */
	public static int MaxPayloadSize = 0xFFFF - (4 * 1024);

	// ==============================================================================================
	// 損失率
	// ==============================================================================================
	/**
	 * このブロックが過負荷などによって消失しても良い確率を表す 0〜127 までの値です。
	 * 0 はこのブロックが消失しないことを表し、127 は 100% の消失が発生しても良い事を示します。
	 * EOF を示す場合は必ず 0 になります。
	 * 消失判定を行い生き残ったブロックは 0 に変更されます。
	 */
	public final byte loss;

	// ==============================================================================================
	// データ
	// ==============================================================================================
	/**
	 * このブロックが転送するデータです。
	 */
	public final byte[] payload;

	// ==============================================================================================
	// オフセット
	// ==============================================================================================
	/**
	 * バッファ内で有効なデータの開始位置を表すオフセットです。
	 */
	public final int offset;

	// ==============================================================================================
	// 長さ
	// ==============================================================================================
	/**
	 * バッファ内で有効なデータの長さを表す値です。
	 */
	public final int length;

	// ==============================================================================================
	// EOF
	// ==============================================================================================
	/**
	 * このブロックが EOF を表すかを示すフラグです。
	 */
	public final boolean eof;

	// ==============================================================================================
	// コンストラクタ
	// ==============================================================================================
	/**
	 * Block メッセージを構築します。
	 * {@link #MaxPayloadSize} より大きいペイロードを指定すると例外が発生します。
	 */
	private Block(short pipeId, byte loss, byte[] payload, int offset, int length, boolean eof){
		super(pipeId);
		if(payload == null){
			throw new NullPointerException("payload is null");
		}
		if(offset + length > payload.length){
			throw new IllegalArgumentException("buffer overrun: offset=" + offset + ", length=" + length + ", actual=" + payload.length);
		}
		if(offset < 0 || length < 0){
			throw new IllegalArgumentException("negative value: offset=" + offset + ", length=" + length);
		}
		if(length > MaxPayloadSize){
			throw new IllegalArgumentException("too long payload: " + length + ", max=" + MaxPayloadSize);
		}
		if(loss < 0){
			throw new IllegalArgumentException("invalid loss-rate: " + loss);
		}
		this.loss = loss;
		this.payload = payload;
		this.offset = offset;
		this.length = length;
		this.eof = eof;
	}

	// ==============================================================================================
	// コンストラクタ
	// ==============================================================================================
	/**
	 * Block メッセージを構築します。
	 */
	public Block(short pipeId, byte loss, byte[] payload, int offset, int length){
		this(pipeId, loss, payload, offset, length, false);
	}

	// ==============================================================================================
	// コンストラクタ
	// ==============================================================================================
	/**
	 * Block メッセージを構築します。
	 */
	public Block(short pipeId, byte[] payload, int offset, int length){
		this(pipeId, (byte)0, payload, offset, length, false);
	}

	// ==============================================================================================
	// ByteBuffer の参照
	// ==============================================================================================
	/**
	 * このブロックのペイロードを ByteBuffer として参照します。
	 * オフセットの指定により初期状態のポジションが 0 でない可能性があります。
	 */
	public ByteBuffer toByteBuffer(){
		return ByteBuffer.wrap(payload, offset, length);
	}

	// ==============================================================================================
	// 文字列の参照
	// ==============================================================================================
	/**
	 * このブロックのペイロードを UTF-8 でエンコードされた文字列として参照します。
	 */
	public String getString(){
		return getString(Asterisque.UTF8);
	}

	// ==============================================================================================
	// 文字列の参照
	// ==============================================================================================
	/**
	 * このブロックのペイロードを指定された文字セットでエンコードされた文字列として参照します。
	 */
	public String getString(Charset charset){
		return new String(payload, offset, length, charset);
	}

	// ==============================================================================================
	// インスタンスの文字列化
	// ==============================================================================================
	/**
	 * このインスタンスを文字列化します。
	 */
	@Override
	public String toString(){
		if(eof){
			return "Block(EOF)";
		}
		StringBuilder buffer = new StringBuilder(length * 3);
		for(int i=0; i<length; i++){
			if(i != 0){
				buffer.append(",");
			}
			buffer.append(String.format("%02X", payload[offset + i]));
		}
		return "Block(" + pipeId + ",[" + buffer + "]," + loss + ")";
	}

	// ==============================================================================================
	// EOF ブロックの構築
	// ==============================================================================================
	/**
	 * 指定されたパイプ ID に対する EOF ブロックを構築します。
	 */
	public static Block eof(short pipeId){
		return new Block(pipeId, (byte)0, Empty, 0, 0, true);
	}

	// ==============================================================================================
	// 空ペイロード
	// ==============================================================================================
	/**
	 * 空のペイロードを Singleton で扱うためのバイト配列です。
	 */
	public static final byte[] Empty = new byte[0];

}
